/*
  Use Case library for Offers.
  Offers are created by a webhook trigger from the P2WDB. Offers are a result of
  new data in P2WDB. They differ from Offers, which are generated by a local
  user.
  An Offer is created to match a local Offer, but it's created indirectly, as
  a response to the webhook from the P2WDB. In this way, Offers generated from
  local Offers are no different than Offers generated by other peers.
*/

// Local libraries
const OfferEntity = require('../../entities/offer')
const config = require('../../../config')

class OfferUseCases {
  constructor (localConfig = {}) {
    // console.log('User localConfig: ', localConfig)
    this.adapters = localConfig.adapters
    if (!this.adapters) {
      throw new Error(
        'Instance of adapters must be passed in when instantiating Offer Use Cases library.'
      )
    }

    this.offerEntity = new OfferEntity()
    this.OfferModel = this.adapters.localdb.Offer
    this.config = config

    this.completeOffer = this.completeOffer.bind(this)
  }

  // This method is called by the POST /offer REST API controller, which is
  // triggered by a P2WDB webhook.
  async createOffer (offerObj) {
    try {
      console.log('Use Case createOffer(offerObj): ', offerObj)

      // console.log('this.adapters.bchjs: ', this.adapters.bchjs)

      // Verify that UTXO in offer is unspent. If it is spent, then ignore the
      // offer.
      const txid = offerObj.data.utxoTxid
      const vout = offerObj.data.utxoVout

      // Verify that the UTXO is valid and not spent.
      const utxoStatus = await this.adapters.wallet.getTxOut(txid, vout)
      console.log('utxoStatus: ', utxoStatus)
      if (!utxoStatus) return false

      // Ensure the record does not already exist. Prevent creating duplicate Offers.
      const p2wdbHash = offerObj.p2wdbHash
      const prevOffers = await this.OfferModel.find({ p2wdbHash })
      if (prevOffers.length > 0) {
        console.log(`Duplicate entry. An Offer with P2WDB hash ${p2wdbHash} already exists in the avax-dex database.`)
        return false
      }

      const offerEntity = this.offerEntity.validate(offerObj)
      console.log('offerEntity: ', offerEntity)

      // Add offer to the local database.
      const offerModel = new this.OfferModel(offerEntity)
      await offerModel.save()

      return true
    } catch (err) {
      console.error('Error in use-cases/offer/createOffer()', err)
      throw err
    }
  }

  async listOffers () {
    try {
      return this.OfferModel.find({})
    } catch (error) {
      console.error('Error in use-cases/offer/listOffers()')
      throw error
    }
  }

  // 'take' an offer by completing the second half of the partial transaction.
  // Write the partially-signed tx to the P2WDB and send a signal to the maker.
  async takeOffer (entryObj) {
    try {
      console.log('Use-Case takeOffer(entryObj):', entryObj)
      const { txHex, addrReferences, p2wdbHash, offerStatus } = entryObj

      // Ensure the offer is in a 'posted' state and not already 'taken'
      if (offerStatus && offerStatus !== 'posted') {
        throw new Error('offer already taken')
      }

      // Prepare to write to the P2WDB.
      await this.adapters.wallet.bchWallet.walletInfoPromise
      await this.adapters.p2wdb.checkForSufficientFunds(
        this.adapters.wallet.bchWallet.walletInfo.privateKey
      )

      // Complete the partial-transaction, taking the other side of the trade.
      const reference = JSON.parse(addrReferences)
      const partialTx = await this.adapters.wallet.takePartialTxHex(
        txHex,
        reference
      )

      // The P2WDB hash of the 'posted' Offer.
      entryObj.offerHash = p2wdbHash

      // Delete properties from the original Offer.
      delete entryObj.p2wdbHash
      delete entryObj.timestamp
      delete entryObj.localTimestamp
      delete entryObj.txid

      // Update the state of the Offer to reflect that it has been 'taken'.
      entryObj.offerStatus = 'taken'
      entryObj.txHex = partialTx.txHex
      entryObj.addrReferences = partialTx.addrReferences
      entryObj.dataType = 'counter'

      console.log(`Writing this data to P2WDB: ${JSON.stringify(entryObj, null, 2)}`)

      // Write the updated offer information to the P2WDB.
      const hash = await this.adapters.p2wdb.write({
        wif: this.adapters.wallet.bchWallet.walletInfo.privateKey,
        data: entryObj,
        appId: this.config.appId
      })

      return hash
    } catch (err) {
      console.log('Error in use-cases/takeOffer())', err)
      throw err
    }
  }

  async completeOffer (entryObj, orderUseCase) {
    try {
      console.log('Use-Case completeOffer(entryObj):', entryObj)

      // See if this instance of avax-dex is managing the Order associated with
      // the incoming Counter Offer.
      const orderHash = entryObj.data.offerHash
      let orderData = {}
      try {
        orderData = await orderUseCase.findOrderByHash(orderHash)
        console.log(`orderData: ${JSON.stringify(orderData, null, 2)}`)
      } catch (err) {
        console.log('Error trying to retrieve order: ', err)

        console.log('Order matching this Counter Offer is not managed by this instance of bch-dex. Exiting.')
        return 'N/A'
      }

      const offerTxHex = orderData.txHex
      const hdIndex = orderData.hdIndex

      // Find the Order.
      // const offerHash = entryObj.data.offerHash
      const offerEntity = await this.findOfferByHash(entryObj.data.offerHash)
      console.log(`Offer entity: ${JSON.stringify(offerEntity, null, 2)}`)

      // const orderEntity = await orderUseCase.findOrderByHash(offerEntity.offerHash)
      const offerStatus = entryObj.data.offerStatus

      // const { offerTxHex, offerEntity, hdIndex } = entryObj
      // const { txHex, addrReferences, offerStatus } = offerEntity

      // Ensure the offer is in a 'taken' state and not already 'completed' or just 'posted'
      if (offerStatus && offerStatus !== 'taken') {
        throw new Error('offerStatus must be taken')
      }

      // Prepare to write to the P2WDB.
      await this.adapters.wallet.bchWallet.walletInfoPromise
      await this.adapters.p2wdb.checkForSufficientFunds(
        this.adapters.wallet.bchWallet.walletInfo.privateKey
      )

      // Delete properties from the original Offer.
      delete entryObj.p2wdbHash
      delete entryObj.timestamp
      delete entryObj.localTimestamp
      delete entryObj.txHex
      delete entryObj.addrReferences

      const txHex = entryObj.data.txHex
      const addrReferences = entryObj.data.addrReferences

      const { valid, message } = await this.adapters.wallet.validateIntegrity(offerTxHex, txHex)

      if (!valid) {
        throw new Error(message)
      }
      const reference = JSON.parse(addrReferences)
      const txid = await this.adapters.wallet.completeTxHex(txHex, reference, hdIndex)
      entryObj.txid = txid
      entryObj.offerStatus = 'accepted'

      // CT 8/7/22 The acceptance TX info does not need to be written to the P2WDB.
      // The garbage collection function should detect that the UTXO has been
      // spent and delete the entry from the database.
      //
      // Write the updated offer information to the P2WDB.
      // const hash = await this.adapters.p2wdb.write({
      //   wif: this.adapters.wallet.bchWallet.walletInfo.privateKey,
      //   data: entryObj,
      //   appId: this.config.appId
      // })

      return { txid }
    } catch (error) {
      console.error('Error in completeOffer(): ', error)
      throw error
    }
  }

  async findOfferByHash (p2wdbHash) {
    try {
      if (typeof p2wdbHash !== 'string' || !p2wdbHash) {
        throw new Error('p2wdbHash must be a string')
      }

      const offer = await this.OfferModel.findOne({ p2wdbHash })

      if (!offer) {
        throw new Error('offer not found')
      }

      const offerObject = offer.toObject()
      return this.offerEntity.validateFromModel(offerObject)
    } catch (err) {
      console.error('Error in findOffer(): ', err)
      throw err
    }
  }

  async findOffer (offerId) {
    try {
      const offer = await this.OfferModel.findById(offerId)

      if (!offer) {
        throw new Error('offer not found')
      }

      const offerObject = offer.toObject()
      return this.offerEntity.validateFromModel(offerObject)
    } catch (err) {
      console.error('Error in findOffer(): ', err)
      throw err
    }
  }

  async checkTakenOffer (offerHash) {
    try {
      const offer = await this.OfferModel.findOne({ offerHash, offerStatus: 'taken' })

      if (!offer) {
        return false
      }

      const offerObject = offer.toObject()
      return this.offerEntity.validateFromModel(offerObject)
    } catch (err) {
      console.error('Error in checkTakenOffer(): ', err)
      throw err
    }
  }

  // This function is called by the garbage collection timer controller. It
  // checks the UTXO associated with each Offer in the database. If the UTXO
  // has been spent, the Order is deleted from the database.
  async removeStaleOffers () {
    try {
      const now = new Date()
      console.log(`Starting garbage collection for Offers at ${now.toLocaleString()}`)

      // Get all Orders in the database.
      const offers = await this.OfferModel.find({})
      // console.log('orders: ', orders)

      // Loop through each Order and ensure the UTXO is still valid.
      for (let i = 0; i < offers.length; i++) {
        const thisOffer = offers[i]
        // console.log(`thisOrder: ${JSON.stringify(thisOrder, null, 2)}`)

        // Check if UTXO is still valie
        const result = await this.adapters.wallet.getTxOut(thisOffer.utxoTxid, thisOffer.utxoVout)
        // console.log('result: ', result)

        // null means UTXO has been spent and order is no longer valid.
        if (result === null) {
          console.log('Removing this Offer that contains an spent UTXO: ', JSON.stringify(thisOffer, null, 2))

          // Delete the model from the database.
          await thisOffer.remove()
        }
      }

      return true
    } catch (err) {
      console.error('Error in removeStaleOffers(): ', err)
      // throw err
    }
  }
}

module.exports = OfferUseCases
